"""Post-IA Image Validation.

Validates images generated by IA before storing in R2.
Based on Kimi's considerations for quality assurance.

Checks:
- Minimum dimensions (512x512)
- Aspect ratio (1:1 with tolerance)
- Alpha channel (transparency)
- File size limits
- Image corruption
- SVG conversion (auto-converts to PNG)
"""

import io
import logging
from dataclasses import dataclass, field
from typing import Optional, Tuple

from PIL import Image

from app.logos.config import get_logos_settings

logger = logging.getLogger(__name__)
logos_settings = get_logos_settings()

# SVG detection magic bytes
SVG_SIGNATURES = [
    b"<?xml",
    b"<svg",
    b"<!DOCTYPE svg",
]


def is_svg(data: bytes) -> bool:
    """Check if data is an SVG file by looking at the content."""
    # Check first 1KB for SVG signatures
    header = data[:1024].lower()
    return any(sig.lower() in header for sig in SVG_SIGNATURES)


def convert_svg_to_png(svg_bytes: bytes, output_size: int = 1024) -> Tuple[bytes, Optional[str]]:
    """Convert SVG to PNG using cairosvg.

    Args:
        svg_bytes: Raw SVG file bytes
        output_size: Target width/height in pixels (default 1024)

    Returns:
        Tuple of (PNG bytes, error message or None)
    """
    try:
        import cairosvg
    except ImportError:
        return b"", "cairosvg not installed - cannot convert SVG"

    try:
        png_bytes = cairosvg.svg2png(
            bytestring=svg_bytes,
            output_width=output_size,
            output_height=output_size,
        )
        logger.info(f"Converted SVG to PNG ({len(svg_bytes)} → {len(png_bytes)} bytes)")
        return png_bytes, None
    except Exception as e:
        logger.error(f"SVG conversion failed: {e}")
        return b"", f"SVG conversion failed: {e}"


@dataclass
class ValidationResult:
    """Result of image validation."""

    valid: bool
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)

    # Image metadata (populated if image loads successfully)
    width: Optional[int] = None
    height: Optional[int] = None
    format: Optional[str] = None
    mode: Optional[str] = None
    has_alpha: bool = False
    file_size_bytes: int = 0

    # SVG conversion info
    converted_from_svg: bool = False
    converted_bytes: Optional[bytes] = None  # PNG bytes if converted

    def __str__(self) -> str:
        if self.valid:
            suffix = " (converted from SVG)" if self.converted_from_svg else ""
            return f"Valid ({self.width}x{self.height}, {self.mode}){suffix}"
        return f"Invalid: {', '.join(self.errors)}"


def validate_ia_output(
    image_bytes: bytes,
    variant: str,
    min_width: Optional[int] = None,
    min_height: Optional[int] = None,
    require_alpha: bool = True,
) -> ValidationResult:
    """Validate image generated by IA.

    Args:
        image_bytes: Raw image bytes from IA response
        variant: Logo variant being validated (for logging)
        min_width: Minimum width (default from settings)
        min_height: Minimum height (default from settings)
        require_alpha: Whether to require alpha channel

    Returns:
        ValidationResult with valid flag, errors, and metadata
    """
    min_width = min_width or logos_settings.LOGOS_MIN_WIDTH
    min_height = min_height or logos_settings.LOGOS_MIN_HEIGHT
    max_size = logos_settings.LOGOS_MAX_FILE_SIZE_BYTES
    aspect_tolerance = logos_settings.LOGOS_ASPECT_RATIO_TOLERANCE

    errors: list[str] = []
    warnings: list[str] = []

    # Check file size first (before attempting to load)
    file_size = len(image_bytes)
    if file_size > max_size:
        errors.append(
            f"File size {file_size / 1024 / 1024:.2f}MB exceeds limit "
            f"{max_size / 1024 / 1024:.2f}MB"
        )
        return ValidationResult(
            valid=False,
            errors=errors,
            file_size_bytes=file_size,
        )

    if file_size == 0:
        errors.append("Empty image data")
        return ValidationResult(valid=False, errors=errors)

    # Attempt to load image
    try:
        img = Image.open(io.BytesIO(image_bytes))
        img.load()  # Force load to detect corruption
    except Exception as e:
        errors.append(f"Image corrupted or invalid format: {e}")
        return ValidationResult(
            valid=False,
            errors=errors,
            file_size_bytes=file_size,
        )

    width, height = img.size
    img_format = img.format
    img_mode = img.mode
    has_alpha = img_mode in ("RGBA", "LA", "PA")

    # Dimension checks
    if width < min_width:
        errors.append(f"Width {width}px below minimum {min_width}px")
    if height < min_height:
        errors.append(f"Height {height}px below minimum {min_height}px")

    # Aspect ratio check (should be ~1:1)
    if width > 0 and height > 0:
        ratio = width / height
        if not (1 - aspect_tolerance <= ratio <= 1 + aspect_tolerance):
            errors.append(f"Aspect ratio {ratio:.2f} not within 1:1 ± {aspect_tolerance}")

    # Alpha channel check
    if require_alpha and not has_alpha:
        # This is a warning for some models that don't support transparency
        warnings.append(f"Image mode '{img_mode}' has no alpha channel")

    # Format check
    if img_format not in ("PNG", "WEBP"):
        warnings.append(f"Format '{img_format}' may not support transparency")

    valid = len(errors) == 0

    if not valid:
        logger.warning(
            f"Validation failed for {variant}: {errors}, "
            f"size={width}x{height}, mode={img_mode}"
        )
    elif warnings:
        logger.info(f"Validation passed with warnings for {variant}: {warnings}")

    return ValidationResult(
        valid=valid,
        errors=errors,
        warnings=warnings,
        width=width,
        height=height,
        format=img_format,
        mode=img_mode,
        has_alpha=has_alpha,
        file_size_bytes=file_size,
    )


def validate_original_logo(image_bytes: bytes) -> ValidationResult:
    """Validate original logo before IA processing.

    Less strict than IA output validation:
    - Alpha channel optional
    - Smaller minimum size allowed
    - Automatically converts SVG to PNG

    Args:
        image_bytes: Raw image bytes

    Returns:
        ValidationResult (with converted_bytes if SVG was converted)
    """
    converted_from_svg = False
    converted_bytes = None

    # Auto-convert SVG to PNG
    if is_svg(image_bytes):
        logger.info("Detected SVG upload, converting to PNG...")
        png_bytes, error = convert_svg_to_png(image_bytes, output_size=1024)
        if error:
            return ValidationResult(
                valid=False,
                errors=[error],
                file_size_bytes=len(image_bytes),
            )
        converted_from_svg = True
        converted_bytes = png_bytes
        image_bytes = png_bytes

    result = validate_ia_output(
        image_bytes,
        variant="original",
        min_width=64,
        min_height=64,
        require_alpha=False,
    )

    # Add conversion info to result
    result.converted_from_svg = converted_from_svg
    result.converted_bytes = converted_bytes

    return result


def validate_batch_results(
    results: dict[str, bytes],
    expected_variants: list[str],
) -> tuple[dict[str, ValidationResult], bool]:
    """Validate all variants from a batch generation.

    Args:
        results: Dict mapping variant name to image bytes
        expected_variants: List of expected variant names

    Returns:
        Tuple of (validation results dict, all_valid bool)
    """
    validations: dict[str, ValidationResult] = {}
    all_valid = True

    # Check for missing variants
    for variant in expected_variants:
        if variant not in results:
            validations[variant] = ValidationResult(
                valid=False,
                errors=[f"Missing variant: {variant}"],
            )
            all_valid = False
            continue

        # Validate each variant
        result = validate_ia_output(results[variant], variant)
        validations[variant] = result
        if not result.valid:
            all_valid = False

    return validations, all_valid


def should_retry(validation: ValidationResult, retry_count: int) -> bool:
    """Determine if generation should be retried based on validation result.

    Args:
        validation: ValidationResult from validate_ia_output
        retry_count: Current retry count

    Returns:
        True if should retry, False if should fail permanently
    """
    max_retries = logos_settings.LOGOS_IA_MAX_RETRIES

    if validation.valid:
        return False

    if retry_count >= max_retries:
        logger.warning(
            f"Max retries ({max_retries}) reached, marking as permanent failure"
        )
        return False

    # Certain errors are not retryable
    non_retryable_errors = [
        "Empty image data",
        "exceeds limit",
    ]

    for error in validation.errors:
        for non_retryable in non_retryable_errors:
            if non_retryable in error:
                logger.warning(f"Non-retryable error: {error}")
                return False

    return True
