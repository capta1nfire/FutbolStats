"""Post-IA Image Validation.

Validates images generated by IA before storing in R2.
Based on Kimi's considerations for quality assurance.

Checks:
- Minimum dimensions (512x512)
- Aspect ratio (1:1 with tolerance)
- Alpha channel (transparency)
- File size limits
- Image corruption
- SVG conversion (auto-converts to PNG)
"""

import io
import logging
from dataclasses import dataclass, field
from typing import Optional, Tuple

from PIL import Image

from app.logos.config import get_logos_settings

logger = logging.getLogger(__name__)
logos_settings = get_logos_settings()

# SVG detection magic bytes
SVG_SIGNATURES = [
    b"<?xml",
    b"<svg",
    b"<!DOCTYPE svg",
]


def is_svg(data: bytes) -> bool:
    """Check if data is an SVG file by looking at the content."""
    # Check first 1KB for SVG signatures
    header = data[:1024].lower()
    return any(sig.lower() in header for sig in SVG_SIGNATURES)


def convert_svg_to_png(svg_bytes: bytes, max_size: int = 1024) -> Tuple[bytes, Optional[str]]:
    """Convert SVG to PNG using cairosvg, preserving aspect ratio.

    Args:
        svg_bytes: Raw SVG file bytes
        max_size: Maximum dimension (larger side) in pixels (default 1024)

    Returns:
        Tuple of (PNG bytes, error message or None)

    Note: This preserves the original aspect ratio. If the SVG is not square,
    the output PNG will also not be square. Use pad_to_square() afterwards
    if a square image is needed.
    """
    try:
        import cairosvg
    except ImportError:
        return b"", "cairosvg not installed - cannot convert SVG"

    try:
        # First, convert at default size to get original dimensions
        temp_png = cairosvg.svg2png(bytestring=svg_bytes)
        temp_img = Image.open(io.BytesIO(temp_png))
        orig_width, orig_height = temp_img.size

        # Calculate scale to fit within max_size while preserving aspect ratio
        if orig_width >= orig_height:
            # Landscape or square: constrain by width
            scale = max_size / orig_width
            output_width = max_size
            output_height = int(orig_height * scale)
        else:
            # Portrait: constrain by height
            scale = max_size / orig_height
            output_width = int(orig_width * scale)
            output_height = max_size

        # Convert with correct dimensions (preserving aspect ratio)
        png_bytes = cairosvg.svg2png(
            bytestring=svg_bytes,
            output_width=output_width,
            output_height=output_height,
        )
        logger.info(
            f"Converted SVG to PNG: {orig_width}x{orig_height} → {output_width}x{output_height} "
            f"({len(svg_bytes)} → {len(png_bytes)} bytes)"
        )
        return png_bytes, None
    except Exception as e:
        logger.error(f"SVG conversion failed: {e}")
        return b"", f"SVG conversion failed: {e}"


def pad_to_square(image_bytes: bytes, target_size: int = 1024) -> Tuple[bytes, Optional[str]]:
    """Pad non-square image to square with transparent background.

    Centers the original image in a square canvas. Useful for logos with
    crowns, stars, or other elements that make them non-square.

    Args:
        image_bytes: Raw image bytes (PNG/JPEG/etc)
        target_size: Target width/height in pixels (default 1024)

    Returns:
        Tuple of (PNG bytes with padding, error message or None)
    """
    try:
        img = Image.open(io.BytesIO(image_bytes))
        img.load()
    except Exception as e:
        return b"", f"Failed to load image: {e}"

    width, height = img.size

    # Already square (within tolerance)
    if abs(width - height) <= 2:
        # Just resize if needed
        if width != target_size:
            img = img.resize((target_size, target_size), Image.Resampling.LANCZOS)
            output = io.BytesIO()
            img.save(output, format="PNG")
            return output.getvalue(), None
        return image_bytes, None

    # Calculate padding to make square
    max_dim = max(width, height)
    scale = target_size / max_dim

    # Scale image to fit in target_size
    new_width = int(width * scale)
    new_height = int(height * scale)
    img_resized = img.resize((new_width, new_height), Image.Resampling.LANCZOS)

    # Create square canvas with transparency
    canvas = Image.new("RGBA", (target_size, target_size), (0, 0, 0, 0))

    # Center the image
    x_offset = (target_size - new_width) // 2
    y_offset = (target_size - new_height) // 2

    # Handle images without alpha channel
    if img_resized.mode != "RGBA":
        img_resized = img_resized.convert("RGBA")

    canvas.paste(img_resized, (x_offset, y_offset), img_resized)

    # Save to bytes
    output = io.BytesIO()
    canvas.save(output, format="PNG")
    padded_bytes = output.getvalue()

    logger.info(
        f"Padded {width}x{height} → {target_size}x{target_size} "
        f"(centered at {x_offset},{y_offset})"
    )
    return padded_bytes, None


@dataclass
class ValidationResult:
    """Result of image validation."""

    valid: bool
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)

    # Image metadata (populated if image loads successfully)
    width: Optional[int] = None
    height: Optional[int] = None
    format: Optional[str] = None
    mode: Optional[str] = None
    has_alpha: bool = False
    file_size_bytes: int = 0

    # SVG conversion info
    converted_from_svg: bool = False
    converted_bytes: Optional[bytes] = None  # PNG bytes if converted
    original_svg_bytes: Optional[bytes] = None  # Original SVG preserved for storage

    # Padding info (for non-square logos like those with crowns)
    padded_to_square: bool = False
    original_dimensions: Optional[Tuple[int, int]] = None  # Before padding

    def __str__(self) -> str:
        if self.valid:
            suffix = ""
            if self.converted_from_svg:
                suffix += " (from SVG)"
            if self.padded_to_square:
                suffix += " (padded)"
            return f"Valid ({self.width}x{self.height}, {self.mode}){suffix}"
        return f"Invalid: {', '.join(self.errors)}"


def validate_ia_output(
    image_bytes: bytes,
    variant: str,
    min_width: Optional[int] = None,
    min_height: Optional[int] = None,
    require_alpha: bool = True,
) -> ValidationResult:
    """Validate image generated by IA.

    Args:
        image_bytes: Raw image bytes from IA response
        variant: Logo variant being validated (for logging)
        min_width: Minimum width (default from settings)
        min_height: Minimum height (default from settings)
        require_alpha: Whether to require alpha channel

    Returns:
        ValidationResult with valid flag, errors, and metadata
    """
    min_width = min_width or logos_settings.LOGOS_MIN_WIDTH
    min_height = min_height or logos_settings.LOGOS_MIN_HEIGHT
    max_size = logos_settings.LOGOS_MAX_FILE_SIZE_BYTES
    aspect_tolerance = logos_settings.LOGOS_ASPECT_RATIO_TOLERANCE

    errors: list[str] = []
    warnings: list[str] = []

    # Check file size first (before attempting to load)
    file_size = len(image_bytes)
    if file_size > max_size:
        errors.append(
            f"File size {file_size / 1024 / 1024:.2f}MB exceeds limit "
            f"{max_size / 1024 / 1024:.2f}MB"
        )
        return ValidationResult(
            valid=False,
            errors=errors,
            file_size_bytes=file_size,
        )

    if file_size == 0:
        errors.append("Empty image data")
        return ValidationResult(valid=False, errors=errors)

    # Attempt to load image
    try:
        img = Image.open(io.BytesIO(image_bytes))
        img.load()  # Force load to detect corruption
    except Exception as e:
        errors.append(f"Image corrupted or invalid format: {e}")
        return ValidationResult(
            valid=False,
            errors=errors,
            file_size_bytes=file_size,
        )

    width, height = img.size
    img_format = img.format
    img_mode = img.mode
    has_alpha = img_mode in ("RGBA", "LA", "PA")

    # Dimension checks
    if width < min_width:
        errors.append(f"Width {width}px below minimum {min_width}px")
    if height < min_height:
        errors.append(f"Height {height}px below minimum {min_height}px")

    # Aspect ratio check (should be ~1:1)
    if width > 0 and height > 0:
        ratio = width / height
        if not (1 - aspect_tolerance <= ratio <= 1 + aspect_tolerance):
            errors.append(f"Aspect ratio {ratio:.2f} not within 1:1 ± {aspect_tolerance}")

    # Alpha channel check
    if require_alpha and not has_alpha:
        # This is a warning for some models that don't support transparency
        warnings.append(f"Image mode '{img_mode}' has no alpha channel")

    # Format check
    if img_format not in ("PNG", "WEBP"):
        warnings.append(f"Format '{img_format}' may not support transparency")

    valid = len(errors) == 0

    if not valid:
        logger.warning(
            f"Validation failed for {variant}: {errors}, "
            f"size={width}x{height}, mode={img_mode}"
        )
    elif warnings:
        logger.info(f"Validation passed with warnings for {variant}: {warnings}")

    return ValidationResult(
        valid=valid,
        errors=errors,
        warnings=warnings,
        width=width,
        height=height,
        format=img_format,
        mode=img_mode,
        has_alpha=has_alpha,
        file_size_bytes=file_size,
    )


def validate_original_logo(image_bytes: bytes) -> ValidationResult:
    """Validate original logo before IA processing.

    Less strict than IA output validation:
    - Alpha channel optional
    - Smaller minimum size allowed
    - Automatically converts SVG to PNG (preserves original SVG)
    - Auto-pads non-square images to square (logos with crowns, stars, etc.)

    Args:
        image_bytes: Raw image bytes

    Returns:
        ValidationResult (with converted_bytes containing the final PNG
        ready for IA processing - converted from SVG and/or padded to square)
    """
    converted_from_svg = False
    original_svg_bytes = None
    padded_to_square = False
    original_dimensions = None
    errors: list[str] = []

    # Step 1: Auto-convert SVG to PNG (preserve original SVG for storage)
    if is_svg(image_bytes):
        logger.info("Detected SVG upload, converting to PNG...")
        original_svg_bytes = image_bytes  # Preserve original SVG
        png_bytes, error = convert_svg_to_png(image_bytes, output_size=1024)
        if error:
            return ValidationResult(
                valid=False,
                errors=[error],
                file_size_bytes=len(image_bytes),
            )
        converted_from_svg = True
        image_bytes = png_bytes

    # Step 2: Load image to check dimensions
    try:
        img = Image.open(io.BytesIO(image_bytes))
        img.load()
    except Exception as e:
        return ValidationResult(
            valid=False,
            errors=[f"Failed to load image: {e}"],
            file_size_bytes=len(image_bytes),
        )

    width, height = img.size
    original_dimensions = (width, height)

    # Check minimum dimensions
    if width < 64 or height < 64:
        errors.append(f"Image too small: {width}x{height} (minimum 64x64)")
        return ValidationResult(
            valid=False,
            errors=errors,
            width=width,
            height=height,
            file_size_bytes=len(image_bytes),
        )

    # Step 3: Auto-pad to square if needed (for logos with crowns, etc.)
    aspect_ratio = width / height
    tolerance = logos_settings.LOGOS_ASPECT_RATIO_TOLERANCE
    needs_padding = not (1 - tolerance <= aspect_ratio <= 1 + tolerance)

    if needs_padding:
        logger.info(f"Non-square image ({width}x{height}, ratio {aspect_ratio:.2f}), padding to square...")
        padded_bytes, error = pad_to_square(image_bytes, target_size=1024)
        if error:
            return ValidationResult(
                valid=False,
                errors=[error],
                width=width,
                height=height,
                file_size_bytes=len(image_bytes),
            )
        padded_to_square = True
        image_bytes = padded_bytes
        # Update dimensions to final padded size
        width, height = 1024, 1024

    # Step 4: Final validation (should pass now)
    # Re-load to get final metadata
    try:
        final_img = Image.open(io.BytesIO(image_bytes))
        final_img.load()
    except Exception as e:
        return ValidationResult(
            valid=False,
            errors=[f"Failed to process image: {e}"],
            file_size_bytes=len(image_bytes),
        )

    return ValidationResult(
        valid=True,
        errors=[],
        warnings=[],
        width=final_img.width,
        height=final_img.height,
        format=final_img.format,
        mode=final_img.mode,
        has_alpha=final_img.mode in ("RGBA", "LA", "PA"),
        file_size_bytes=len(image_bytes),
        converted_from_svg=converted_from_svg,
        converted_bytes=image_bytes,  # Always set: final PNG ready for IA
        original_svg_bytes=original_svg_bytes,
        padded_to_square=padded_to_square,
        original_dimensions=original_dimensions,
    )


def validate_batch_results(
    results: dict[str, bytes],
    expected_variants: list[str],
) -> tuple[dict[str, ValidationResult], bool]:
    """Validate all variants from a batch generation.

    Args:
        results: Dict mapping variant name to image bytes
        expected_variants: List of expected variant names

    Returns:
        Tuple of (validation results dict, all_valid bool)
    """
    validations: dict[str, ValidationResult] = {}
    all_valid = True

    # Check for missing variants
    for variant in expected_variants:
        if variant not in results:
            validations[variant] = ValidationResult(
                valid=False,
                errors=[f"Missing variant: {variant}"],
            )
            all_valid = False
            continue

        # Validate each variant
        result = validate_ia_output(results[variant], variant)
        validations[variant] = result
        if not result.valid:
            all_valid = False

    return validations, all_valid


def should_retry(validation: ValidationResult, retry_count: int) -> bool:
    """Determine if generation should be retried based on validation result.

    Args:
        validation: ValidationResult from validate_ia_output
        retry_count: Current retry count

    Returns:
        True if should retry, False if should fail permanently
    """
    max_retries = logos_settings.LOGOS_IA_MAX_RETRIES

    if validation.valid:
        return False

    if retry_count >= max_retries:
        logger.warning(
            f"Max retries ({max_retries}) reached, marking as permanent failure"
        )
        return False

    # Certain errors are not retryable
    non_retryable_errors = [
        "Empty image data",
        "exceeds limit",
    ]

    for error in validation.errors:
        for non_retryable in non_retryable_errors:
            if non_retryable in error:
                logger.warning(f"Non-retryable error: {error}")
                return False

    return True
